<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dino Dress-Up — Smoke Test</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: system-ui, sans-serif; padding: 24px; background: #1a1a2e; color: #e0e0e0; }
    h1 { margin-bottom: 16px; color: #fff; }
    .test-grid { display: flex; flex-wrap: wrap; gap: 16px; margin-top: 16px; }
    .test-card {
      background: #16213e; border-radius: 12px; padding: 16px; min-width: 280px;
      border: 2px solid #333; flex: 1;
    }
    .test-card h3 { margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; color: #888; }
    .test-card .result { font-size: 18px; font-weight: bold; margin: 8px 0; }
    .test-card .detail { font-size: 12px; color: #999; margin-top: 4px; white-space: pre-wrap; }
    .pass { color: #4caf50; }
    .fail { color: #f44336; }
    .running { color: #ff9800; }
    canvas { border: 1px solid #444; border-radius: 4px; margin-top: 8px; display: block; background: #000; }
    #summary {
      margin-top: 24px; padding: 16px; border-radius: 8px; font-size: 20px; font-weight: bold; text-align: center;
    }
    #summary.all-pass { background: #1b5e20; color: #4caf50; }
    #summary.has-fail { background: #b71c1c; color: #f44336; }
    #summary.running { background: #e65100; color: #ff9800; }
  </style>
</head>
<body>
  <h1>Dino Dress-Up — Rendering Smoke Test</h1>
  <p>This page tests each stage of the rendering pipeline independently.</p>

  <div id="summary" class="running">Running tests...</div>
  <div id="tests" class="test-grid"></div>

  <script type="module">
    // ── Test framework ──────────────────────────────────────────────
    const results = [];
    const testsEl = document.getElementById('tests');
    const summaryEl = document.getElementById('summary');

    function addTest(name) {
      const card = document.createElement('div');
      card.className = 'test-card';
      card.innerHTML = `<h3>${name}</h3><div class="result running">RUNNING...</div><div class="detail"></div>`;
      testsEl.appendChild(card);
      return {
        pass(msg, detailHtml) {
          card.querySelector('.result').textContent = 'PASS';
          card.querySelector('.result').className = 'result pass';
          if (msg) card.querySelector('.result').textContent = 'PASS — ' + msg;
          if (detailHtml) card.querySelector('.detail').innerHTML = detailHtml;
          results.push({ name, passed: true });
        },
        fail(msg, detailHtml) {
          card.querySelector('.result').textContent = 'FAIL — ' + msg;
          card.querySelector('.result').className = 'result fail';
          if (detailHtml) card.querySelector('.detail').innerHTML = detailHtml;
          results.push({ name, passed: false, msg });
        },
        addCanvas(canvas) {
          card.appendChild(canvas);
        },
        addDetail(text) {
          card.querySelector('.detail').textContent += text + '\n';
        }
      };
    }

    function updateSummary() {
      const total = results.length;
      const passed = results.filter(r => r.passed).length;
      const failed = total - passed;
      if (failed > 0) {
        summaryEl.textContent = `FAIL: ${passed}/${total} passed (${failed} failed)`;
        summaryEl.className = 'has-fail';
      } else {
        summaryEl.textContent = `ALL PASS: ${passed}/${total} tests passed`;
        summaryEl.className = 'all-pass';
      }
    }

    // ── Helpers ──────────────────────────────────────────────────────
    function canvasHasPixels(canvas, threshold = 10) {
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      // If this is a WebGPU canvas we can't getContext('2d') — handle that
      if (!ctx) return { hasPixels: false, nonZeroCount: 0, error: 'Cannot get 2D context (may be WebGPU canvas)' };
      try {
        const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        let nonZeroCount = 0;
        for (let i = 3; i < imgData.data.length; i += 4) {
          if (imgData.data[i] > 0) nonZeroCount++;
        }
        return { hasPixels: nonZeroCount > threshold, nonZeroCount };
      } catch (e) {
        return { hasPixels: false, nonZeroCount: 0, error: e.message };
      }
    }

    // ═══════════════════════════════════════════════════════════════════
    // TEST 1: Module imports
    // ═══════════════════════════════════════════════════════════════════
    const t1 = addTest('Module Imports');
    let DINO_PATHS, TextureManager, Scene, Renderer, Sprite, initGPUContext, CANVAS_WIDTH, CANVAS_HEIGHT;

    try {
      const constants = await import('./src/utils/constants.js');
      CANVAS_WIDTH = constants.CANVAS_WIDTH;
      CANVAS_HEIGHT = constants.CANVAS_HEIGHT;

      const dinoPaths = await import('./src/assets/dino-paths.js');
      DINO_PATHS = dinoPaths.DINO_PATHS;

      const texMgr = await import('./src/core/texture-manager.js');
      TextureManager = texMgr.TextureManager;

      const scene = await import('./src/core/scene.js');
      Scene = scene.Scene;

      const renderer = await import('./src/core/renderer.js');
      Renderer = renderer.Renderer;

      const sprite = await import('./src/core/sprite.js');
      Sprite = sprite.Sprite;

      const gpuCtx = await import('./src/core/gpu-context.js');
      initGPUContext = gpuCtx.initGPUContext;

      const dinoCount = Object.keys(DINO_PATHS).length;
      t1.pass(`${dinoCount} dinos loaded`, `Modules: constants, dino-paths, texture-manager, scene, renderer, sprite, gpu-context`);
    } catch (err) {
      t1.fail(err.message, `Stack: ${err.stack}`);
      updateSummary();
      throw err; // Abort — can't continue without modules
    }

    // ═══════════════════════════════════════════════════════════════════
    // TEST 2: Direct Canvas2D Path2D drawing (same as selection screen)
    // ═══════════════════════════════════════════════════════════════════
    const t2 = addTest('Canvas2D Path2D Drawing');
    try {
      const dinoId = Object.keys(DINO_PATHS)[0];
      const pathData = DINO_PATHS[dinoId];
      const SIZE = 200;
      const canvas = document.createElement('canvas');
      canvas.width = SIZE;
      canvas.height = SIZE;
      const ctx = canvas.getContext('2d');

      // Draw background
      ctx.fillStyle = '#f0ebe0';
      ctx.fillRect(0, 0, SIZE, SIZE);

      // Scale and draw paths (same logic as select-screen.js)
      const scaleX = SIZE / pathData.width;
      const scaleY = SIZE / pathData.height;
      const scale = Math.min(scaleX, scaleY) * 0.85;
      const offsetX = (SIZE - pathData.width * scale) / 2;
      const offsetY = (SIZE - pathData.height * scale) / 2;

      ctx.save();
      ctx.translate(offsetX, offsetY);
      ctx.scale(scale, scale);

      let pathsDrawn = 0;
      for (const segment of pathData.paths) {
        ctx.save();
        const path = new Path2D(segment.d);
        if (segment.opacity !== undefined) ctx.globalAlpha = segment.opacity;
        if (segment.fill && segment.fill !== 'none') {
          ctx.fillStyle = segment.fill;
          ctx.fill(path);
        }
        if (segment.stroke && segment.stroke !== 'none') {
          ctx.strokeStyle = segment.stroke;
          ctx.lineWidth = segment.strokeWidth || 1;
          ctx.stroke(path);
        }
        ctx.restore();
        pathsDrawn++;
      }
      ctx.restore();

      const check = canvasHasPixels(canvas);
      if (check.hasPixels) {
        t2.pass(`${pathsDrawn} paths drawn, ${check.nonZeroCount} non-transparent pixels`, `Dino: ${dinoId}`);
      } else {
        t2.fail(`0 visible pixels after drawing ${pathsDrawn} paths`, `Error: ${check.error || 'Canvas is blank'}`);
      }
      t2.addCanvas(canvas);
    } catch (err) {
      t2.fail(err.message);
    }

    // ═══════════════════════════════════════════════════════════════════
    // TEST 3: SVG Rasterizer (OffscreenCanvas + createImageBitmap)
    // ═══════════════════════════════════════════════════════════════════
    const t3 = addTest('SVG Rasterizer Pipeline');
    try {
      const { rasterizeSVGPaths } = await import('./src/utils/svg-rasterizer.js');

      const dinoId = Object.keys(DINO_PATHS)[0];
      const pathData = DINO_PATHS[dinoId];

      const bitmap = await rasterizeSVGPaths({
        paths: pathData.paths,
        width: pathData.width,
        height: pathData.height,
        scale: 1,
      });

      if (bitmap && bitmap.width > 0 && bitmap.height > 0) {
        t3.pass(`${bitmap.width}x${bitmap.height} bitmap`, `Dino: ${dinoId}`);
        // Draw bitmap to a visible canvas so we can verify
        const canvas = document.createElement('canvas');
        canvas.width = 200;
        canvas.height = 200;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(bitmap, 0, 0, 200, 200);
        t3.addCanvas(canvas);

        const check = canvasHasPixels(canvas);
        t3.addDetail(`Pixel check: ${check.nonZeroCount} non-transparent pixels`);
      } else {
        t3.fail('Bitmap is null or zero-size');
      }
    } catch (err) {
      t3.fail(err.message, `Stack: ${err.stack}`);
    }

    // ═══════════════════════════════════════════════════════════════════
    // TEST 4: GPU Context Init (Canvas2D or WebGPU)
    // ═══════════════════════════════════════════════════════════════════
    const t4 = addTest('GPU Context Init');
    let gpuContext;
    try {
      const canvas = document.createElement('canvas');
      canvas.width = 400;
      canvas.height = 400;
      // Canvas must be in the DOM for some browsers
      canvas.style.display = 'none';
      document.body.appendChild(canvas);

      gpuContext = await initGPUContext(canvas);

      t4.pass(`Mode: ${gpuContext.mode}`, `Canvas: ${canvas.width}x${canvas.height}, ctx2d: ${!!gpuContext.ctx2d}, device: ${!!gpuContext.device}`);
    } catch (err) {
      t4.fail(err.message, `Stack: ${err.stack}`);
    }

    // ═══════════════════════════════════════════════════════════════════
    // TEST 5: TextureManager + loadSVG
    // ═══════════════════════════════════════════════════════════════════
    const t5 = addTest('TextureManager loadSVG');
    let textureManager;
    try {
      const device = gpuContext && gpuContext.device ? gpuContext.device : null;
      textureManager = new TextureManager(device);

      const dinoId = Object.keys(DINO_PATHS)[0];
      const pathData = DINO_PATHS[dinoId];
      const textureId = 'test-dino-' + dinoId;

      await textureManager.loadSVG(textureId, {
        paths: pathData.paths,
        width: pathData.width,
        height: pathData.height,
      });

      const hasTex = textureManager.has(textureId);
      const bitmap = textureManager.getBitmap(textureId);

      if (hasTex && bitmap) {
        t5.pass(`Cached: ${bitmap.width}x${bitmap.height}`, `textureId: ${textureId}, has: ${hasTex}`);
      } else {
        t5.fail(`has=${hasTex}, bitmap=${!!bitmap}`);
      }
    } catch (err) {
      t5.fail(err.message, `Stack: ${err.stack}`);
    }

    // ═══════════════════════════════════════════════════════════════════
    // TEST 6: Full Renderer Pipeline (Canvas2D mode)
    // ═══════════════════════════════════════════════════════════════════
    const t6 = addTest('Full Renderer Pipeline');
    try {
      // Create a VISIBLE canvas for this test
      const canvas = document.createElement('canvas');
      canvas.width = 400;
      canvas.height = 400;
      canvas.style.width = '200px';
      canvas.style.height = '200px';

      // Init a fresh GPU context on this visible canvas
      const testGpuCtx = await initGPUContext(canvas);
      const device = testGpuCtx.device || null;
      const testTexMgr = new TextureManager(device);

      // Load a dino texture
      const dinoId = Object.keys(DINO_PATHS)[0];
      const pathData = DINO_PATHS[dinoId];
      const textureId = 'render-test-' + dinoId;
      await testTexMgr.loadSVG(textureId, {
        paths: pathData.paths,
        width: pathData.width,
        height: pathData.height,
      });

      // Create scene + sprite
      const scene = new Scene();
      const sprite = new Sprite({
        textureId,
        x: 200,
        y: 200,
        width: 300,
        height: 300,
        zIndex: 5,
        anchorX: 0.5,
        anchorY: 0.5,
      });
      scene.add(sprite);
      scene.markDirty();

      // Create renderer and render one frame
      const renderer = new Renderer(testGpuCtx, testTexMgr);
      renderer.setScene(scene);
      renderer.render(0);

      // Check canvas for pixels
      const check = canvasHasPixels(canvas);
      if (check.hasPixels) {
        t6.pass(`${check.nonZeroCount} non-transparent pixels`, `Mode: ${testGpuCtx.mode}, sprite at (200,200) 300x300`);
      } else if (check.error) {
        // WebGPU canvas — can't read pixels with getImageData
        t6.pass(`Rendered (cannot verify pixels in ${testGpuCtx.mode} mode)`, `Mode: ${testGpuCtx.mode}`);
      } else {
        t6.fail(`Canvas blank after render — 0 pixels`, `Mode: ${testGpuCtx.mode}, sprite: ${JSON.stringify({x: sprite.x, y: sprite.y, w: sprite.width, h: sprite.height, visible: sprite.visible})}`);
      }
      t6.addCanvas(canvas);
    } catch (err) {
      t6.fail(err.message, `Stack: ${err.stack}`);
    }

    // ═══════════════════════════════════════════════════════════════════
    // TEST 7: Full game flow simulation
    // ═══════════════════════════════════════════════════════════════════
    const t7 = addTest('Game Flow Simulation');
    try {
      // Simulate: hidden canvas -> init GPU -> make visible -> reconfigure -> render
      const canvas = document.createElement('canvas');
      canvas.style.display = 'none'; // Start hidden (like dressing screen)
      document.body.appendChild(canvas);

      const testGpuCtx = await initGPUContext(canvas);
      const device = testGpuCtx.device || null;
      const testTexMgr = new TextureManager(device);

      const dinoId = Object.keys(DINO_PATHS)[0];
      const pathData = DINO_PATHS[dinoId];
      const textureId = 'flow-test-' + dinoId;
      await testTexMgr.loadSVG(textureId, { paths: pathData.paths, width: pathData.width, height: pathData.height });

      const scene = new Scene();
      const sprite = new Sprite({ textureId, x: 200, y: 200, width: 300, height: 300, zIndex: 5, anchorX: 0.5, anchorY: 0.5 });
      scene.add(sprite);

      const renderer = new Renderer(testGpuCtx, testTexMgr);
      renderer.setScene(scene);

      // Start render loop while hidden (like main.js step 14)
      renderer.start();

      // Wait a moment (simulates user browsing selection screen)
      await new Promise(r => setTimeout(r, 100));

      // Now make canvas visible (simulates screen transition)
      canvas.style.display = 'block';
      canvas.style.width = '200px';
      canvas.style.height = '200px';

      // Reconfigure + force render (like our fixed onEnter)
      renderer.reconfigure();
      scene.markDirty();
      renderer.render(performance.now());

      // Stop the loop so it doesn't keep ticking
      renderer.stop();

      // Check pixels
      const check = canvasHasPixels(canvas);
      if (check.hasPixels) {
        t7.pass(`${check.nonZeroCount} pixels after hidden->visible->reconfigure`, `Mode: ${testGpuCtx.mode}`);
      } else if (check.error) {
        t7.pass(`Rendered (cannot verify pixels in ${testGpuCtx.mode} mode)`);
      } else {
        t7.fail(`Canvas blank after hidden->visible->reconfigure flow`, `Mode: ${testGpuCtx.mode}`);
      }
      t7.addCanvas(canvas);
    } catch (err) {
      t7.fail(err.message, `Stack: ${err.stack}`);
    }

    // ── Summary ─────────────────────────────────────────────────────
    updateSummary();

  </script>
</body>
</html>
